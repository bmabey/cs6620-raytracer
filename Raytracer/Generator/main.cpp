//
// Heightfield generator for program 3
// The heightfield for the test scene was generated by this program
// at a resolution of 200x200 (201x201 data points)
//
// Note: because this makes a binary file, you must generate the data
// on a machine with the same endianness as your renderer.  The easiest
// way to ensure this is to use the same machine.
// Note 2: I know that windows handles binary files strangely, so be
// careful
// 

// I used the following code to read the data in:
//   ifstream in(filename.c_str());
//   if(!in){
//     cerr << "Error opening " << filename << "\n";
//     exit(1);
//   double minz, maxz;
//   in >> nx >> ny >> minz >> maxz;
//   if(!in){
//     cerr << "Error reading hader from " << filename << "\n";
//     exit(1);
//   }
//   in.get();
//   float** data = new float*[nx+1];
//   float* p = new float[(nx+1)*(ny+1)];
//   for(int i=0;i<=nx;i++)
//     data[i] = p+i*(ny+1);
//   in.read(data[0], sizeof(float)*(nx+1)*(ny+1));
//   if(!in){
//     cerr << "Error reading data from " << filename << "\n";
//     exit(1);
//   }


#include <float.h>
#include <fstream>
#include <iostream>
#include <cmath>
using namespace std;

static float f(double x, double y)
{
  // return 3;
  // return y+2;
  double r2 = 10*(x*x+y*y);
    return sin(r2)+sin(x*y) - cos(x*y);
}

int main(int argc, char* argv[])
{
  if(argc != 4){
    cerr << "Usage: " << argv[0] << " nx ny filename\n";
    exit(1);
  }
  int nx=atoi(argv[1]);
  int ny=atoi(argv[2]);
  float** data = new float*[nx+1];
  float* p = new float[(nx+1)*(ny+1)];
  for(int i=0;i<=nx;i++)
    data[i] = p+i*(ny+1);
  float maxz = -FLT_MAX;
  float minz = FLT_MAX;
  for(int i=0;i<=nx;i++){
    double x = double(i)/nx*2-1;
    for(int j=0;j<=ny;j++){
      double y = double(j)/ny*2-1;
      data[i][j] = f(x, y);
      if(data[i][j] < minz)
        minz = data[i][j];
      if(data[i][j] > maxz)
        maxz = data[i][j];
    }
  }
  ofstream out(argv[3], ios::binary);
  out << nx << " " << ny << " " << minz << " " << maxz << " ";
  out.write(reinterpret_cast<char*>(data[0]), sizeof(float)*(nx+1)*(ny+1));
}